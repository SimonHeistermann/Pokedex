<div class="types__container">
                    <div class="type__box">
                        <img src="./assets/icons/icon_grass.png" alt="Grass">
                        Grass
                    </div>
                    <div class="type__box">
                        <img src="./assets/icons/icon_poison.png" alt="Grass">
                        Poison
                    </div>
                </div>

                .pokemon__card {
                    width: 47%;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 24px;
                    padding: 16px;
                    border-radius: 16px;
                    position: relative;
                    overflow: hidden;
                    transition: transform 0.2s ease-in-out;
                    color: white;
                }
                
                .pokemon__card:hover {
                    transform: scale(1.05); 
                }
                
                nav {
                    display: flex;
                    align-items: flex-start;
                    justify-content: space-between;
                }
                
                .nav__container {
                    display: flex;
                    align-items: flex-start;
                    gap: 16px;
                }
                
                nav button {
                    border-width: 0;
                    color:  white;
                    background-color: transparent;
                    font-size: 20px;
                    padding-bottom: 8px;
                    max-height: 39px;
                }
                
                nav button:hover, nav button:active {
                    cursor: pointer;
                    border-bottom: solid 3px white;
                }
                
                .navbutton__open {
                    border-bottom: solid 3px white;
                }
                
                for (const pokemon of pokemonList) {
                    pokemonDetails = await fetchPokemonDetails(pokemon.url);
                    renderPokemonList(contentRef, pokemonDetails);
                }

                async function getNatureName() {
                    try {
                        const response = await fetch('https://pokeapi.co/api/v2/nature/');
                        const data = await response.json();
                        const natures = data.results;
                        for (const nature of natures) {
                            const natureDetails = await fetchNature(nature.name);
                            if ( natureDetails.increased_stat?.name === stats.increased_stat && natureDetails.decreased_stat?.name === stats.decreased_stat) return nature.name;
                        }
                        return "neutral"; 
                    } catch (error) {
                        console.error("Error fetching nature name", error);
                        return null;
                    }
                }



                let allPokemon = [];
let filteredPokemonList = [];
let filteredPokemonDetails;
const searchLimit = 20;   


async function fetchAllPokemon() {
    try {
      const response = await fetch(`${BASE_URL}?offset=${0}&limit=${1025}`);
      const data = await response.json();
      allPokemon = data.results.map(pokemon => pokemon.name);
    } catch (error) {
      console.error('Failed to fetch all Pokémon:', error);
    }
}

function filterPokemon() {
    fetchAllPokemon().then(() => {
        handleSearch();
        displayFilteredPokemonList();
       
    });
}

function handleSearch() {
    const input = document.getElementById('search_input').value.toLowerCase();
    if (input.length >= 3) {
        filteredPokemonList = allPokemon.filter(name => name.includes(input)).slice(0, limit); 
    }
}

async function displayFilteredPokemonList() {
    const contentRef = document.getElementById('pokedex_section');
    contentRef.innerHTML = "";
    for (let indexFilteredPokemon = 0; indexFilteredPokemon < filteredPokemonList.length; indexFilteredPokemon++) {
        filteredPokemonDetails = await fetchPokemonDetails(filteredPokemonList[indexFilteredPokemon].url);
        renderFilteredPokemonList(contentRef, filteredPokemonDetails);
    }
}

function renderFilteredPokemonList(container, pokemon) {
    if(container) {
        container.innerHTML += renderPokemonCardHTML(pokemon);
    }
}

async function fetchPokemonDescription(pokemonID) {
    try {
        const response = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemonID}`);
        const data = await response.json();
        const description = data.flavor_text_entries.find(entry => entry.language.name === "de").flavor_text.replace(/\n|\f/g, " ");
        return  description;
    } catch (error) {
        console.error("Fehler beim Abrufen der Pokemon Beschreibung!")
    }
}

async function fetchPokemonDetails(url) {
    try {
        const response = await fetch(url);
        return response.json();
    } catch (error) {
        console.error("Pokemondetails konnten nicht geladen werden!", error)
    }
}


 // bevoer chtagpt anpassung für server geschwindigkeit und modularität
const BASE_URL = "https://pokeapi.co/api/v2/pokemon";
let pokemonList = [];
let pokemonCache = {};
let currentDetails = 'about';

const limit = 20;
let offset = 0;
let pokemonDetails;


async function init() {
    try {
        await fetchAllPokemon();
        renderStandardStructure(); 
        await fetchPokemonList(); 
        displayPokemonList(); 
        renderMorePokemonButton(); 
    } catch (error) {
        console.error('Error initializing app:', error);
    }
}

function renderStandardStructure() {
    const structureRef = document.getElementById('body');
    if (structureRef) {
        structureRef.innerHTML = "";
        structureRef.innerHTML += renderHTMLStandardStructure();
    } 
}

function renderMorePokemonButton() {
    let contentRef = document.getElementById('morepokemonbutton_section');
    if(contentRef) {
        contentRef.innerHTML = "";
        contentRef.innerHTML += renderHTMLMorePokemonButton();
    }
}

async function displayPokemonList() {
    const contentRef = document.getElementById('pokedex_section');
    for (let indexPokemon = 0; indexPokemon < pokemonList.length; indexPokemon++) {
        if (indexPokemon >= offset) {
            pokemonDetails = await fetchPokemonDetails(pokemonList[indexPokemon].url);
            renderPokemonList(contentRef, pokemonDetails);
        }
    }
}

async function fetchPokemonList() {
    try {
        const response = await fetch(`${BASE_URL}?offset=${offset}&limit=${limit}`);
        const data = await response.json();
        if (!pokemonList) pokemonList = [];
        pokemonList.push(...data.results);
    } catch (error) {
        console.error("Pokemonliste konnte nicht geladen werden!", error);
    }
}

async function fetchPokemonDetails(url) {
    try {
        const response = await fetch(url);
        return response.json();
    } catch (error) {
        console.error("Pokemondetails konnten nicht geladen werden!", error)
    }
}

async function fetchPokemonDescription(pokemonID) {
    try {
        const response = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemonID}`);
        const data = await response.json();
        let descriptionEntry = data.flavor_text_entries.find(entry => entry.language.name === "de");
        if (!descriptionEntry) descriptionEntry = data.flavor_text_entries.find(entry => entry.language.name === "en");
        if (descriptionEntry) return descriptionEntry.flavor_text.replace(/\n|\f/g, " ");
        else return "Keine Beschreibung verfügbar.";
    } catch (error) {
        console.error("Fehler beim Abrufen der Pokémon-Beschreibung!", error);
        return "Fehler beim Laden der Beschreibung.";
    }
}

function renderPokemonList(container, pokemon) {
    if(container) {
        container.innerHTML += renderPokemonCardHTML(pokemon);
    }
}

async function openPokemonDetails(pokemonID) {
    renderOverlayStructure();
    const selectedPokemonDetails = await getPokemonDetails(pokemonID);
    const pokemonDescription = await fetchPokemonDescription(pokemonID);
    openOverlay(selectedPokemonDetails, pokemonDescription);
}

async function getPokemonDetails(pokemonID) {
    const selectedPokemonDetails = await fetchPokemonDetails(`https://pokeapi.co/api/v2/pokemon/${pokemonID}`);
    return selectedPokemonDetails;
}   

function openOverlay(selectedPokemonDetails, pokemonDescription) {
    toggleDnoneFromOverlay();
    currentDetails = "about";
    renderDetailedStructure(selectedPokemonDetails);
    renderDetailedAbout(selectedPokemonDetails, pokemonDescription);
    fixateScrollingOnBody();
}

function closeOverlay() {
    toggleDnoneFromOverlay();
    releaseScrollOnBody();
}

function renderOverlayStructure() {
    const structureRef = document.getElementById('overlay');
    if (structureRef) {
        structureRef.innerHTML = "";
        structureRef.innerHTML += renderHTMLOverlayStructure();
    } 
}

function renderDetailedStructure(pokemon) {
    const structureRef = document.getElementById('mpokemon_details');
    if (structureRef) {
        structureRef.innerHTML = "";
        structureRef.innerHTML += renderHTMLDetailedStructure(pokemon);
    } 
}

function renderDetailedAbout(pokemon, pokemonDescription) {
    const contentRef = document.getElementById('detailed_information');
    if (contentRef) {
        contentRef.innerHTML = "";
        contentRef.innerHTML += renderHTMLDetailedAbout(pokemon, pokemonDescription);
    } 
}

async function displayMorePokemon() {
    offset += limit;
    fetchPokemonList().then(() => {
        displayPokemonList();
    });
}

async function openDetailedStats(pokemonID, navButtonRef) {
    currentDetails = 'stats';
    const selectedPokemonDetails = await getPokemonDetails(pokemonID);
    const natureName = getRandomNatureName();
    changeNavButtonStyling(navButtonRef);
    renderDetailedStats(selectedPokemonDetails);
    loadDynamicNatureDescription(selectedPokemonDetails, natureName);
}

async function renderDetailedStats(pokemon) {
    const contentRef = document.getElementById('detailed_information');
    if (contentRef) {
        contentRef.innerHTML = "";
        contentRef.innerHTML += renderHTMLDetailedStats(pokemon);
    }
}

async function openDetailedAbout(pokemonID, navButtonRef) {
    currentDetails = 'about';
    const selectedPokemonDetails = await getPokemonDetails(pokemonID);
    const pokemonDescription = await fetchPokemonDescription(pokemonID);
    changeNavButtonStyling(navButtonRef);
    renderDetailedAbout(selectedPokemonDetails, pokemonDescription);
}

function getRandomNatureName() {
    const natures = [
        "Hardy", "Lonely", "Brave", "Adamant", "Naughty", 
        "Bold", "Docile", "Relaxed", "Impish", "Lax", 
        "Timid", "Hasty", "Serious", "Jolly", "Naive", 
        "Modest", "Mild", "Quiet", "Bashful", "Rash", 
        "Calm", "Gentle", "Sassy", "Careful", "Quirky", 
        "Mild", "Hasty"
    ];
    return natures[Math.floor(Math.random() * natures.length)];
}

async function fetchNature(natureName) {
    const lowerCaseNatureName = toLowerCaseHelper(natureName);
    try {
        const response = await fetch(`https://pokeapi.co/api/v2/nature/${lowerCaseNatureName}`);
        if (!response.ok) {
            throw new Error("Nature not found");
        }
        return await response.json();
    } catch (error) {
        console.error(`Error fetching details for nature: ${natureName}`, error);
        return null;
    }
}

async function loadDynamicNatureDescription(pokemon, natureName) {
    const contentRef = document.getElementById('nature_description');
    if (natureName) {
        const natureDetails = await fetchNature(natureName);
        if (natureDetails) {
            const increasedStat = natureDetails.increased_stat?.name || "none";
            const decreasedStat = natureDetails.decreased_stat?.name || "none";
            const description = `Based on this Pokémon's stats, we consider the best nature for ${capitalizeFirstLetter(pokemon.name)} to have is <b class="naturetext__bold">${natureName}</b>. This will increase its <b class="naturetext__bold">${increasedStat}</b> and decrease its <b class="naturetext__bold">${decreasedStat}</b> stats.`;
            contentRef.innerHTML = description;
        } else contentRef.innerHTML = "Nature details could not be loaded.";
    } else contentRef.innerHTML = "Nature could not be determined.";
}

async function openNextPokemon(pokemonID) {
    let newPokemonID;
    if(pokemonID === 1025) newPokemonID = 1;
    else newPokemonID = pokemonID + 1;
    if(newPokemonID <= offset) await getAndRenderPrevOrNextPokemon(newPokemonID);
    else {
        await displayMorePokemon();
        await getAndRenderPrevOrNextPokemon(newPokemonID);
    }
}

async function openPrevPokemon(pokemonID) {
    let newPokemonID;
    if(pokemonID === 1) newPokemonID = 1;
    else newPokemonID = pokemonID - 1;
    await getAndRenderPrevOrNextPokemon(newPokemonID);
}

async function getAndRenderPrevOrNextPokemon(newPokemonID) {
    const selectedPokemonDetails = await getPokemonDetails(newPokemonID);
    const pokemonDescription = await fetchPokemonDescription(newPokemonID);
    currentDetails = 'about';
    renderDetailedStructure(selectedPokemonDetails);
    renderDetailedAbout(selectedPokemonDetails, pokemonDescription);
}

let allPokemon = [];
let filteredPokemonList = [];
const searchLimit = 20;   


async function fetchAllPokemon() {
    try {
        const response = await fetch(`${BASE_URL}?offset=0&limit=1025`);
        const data = await response.json();
        allPokemon = data.results;
    } catch (error) {
        console.error('Failed to fetch all Pokémon:', error);
    }
}

async function filterPokemon(event) {
    event.preventDefault();
    const input = document.getElementById('search_input').value.toLowerCase();
    if (input.length >= 3) {
        filteredPokemonList = allPokemon
            .filter(pokemon => pokemon.name.includes(input))
            .slice(0, searchLimit);
        await displayFilteredPokemonList();
    }
    ifEmptySearch(input);
}

async function displayFilteredPokemonList() {
    const contentRef = document.getElementById('pokedex_section');
    contentRef.innerHTML = "";
    for (let pokemon of filteredPokemonList) {
        const pokemonDetails = await fetchPokemonDetails(pokemon.url);
        renderFilteredPokemonList(contentRef, pokemonDetails);
    }
}

function renderFilteredPokemonList(container, pokemon) {
    const morePokemonButtonRef = document.getElementById('morepokemonbutton_section');
    morePokemonButtonRef.innerHTML = "";
    container.innerHTML += renderPokemonCardHTML(pokemon);
}

function ifEmptySearch(input) {
    if (input === "") {
        const contentRef = document.getElementById('pokedex_section');
        contentRef.innerHTML = "";
        displayPokemonListAfterSearch();
        renderMorePokemonButton();
        filteredPokemonList.length = 0;
        return;
    }
};

async function displayPokemonListAfterSearch() {
    const contentRef = document.getElementById('pokedex_section');
    contentRef.innerHTML = "";
    for (let indexPokemon = 0; indexPokemon < pokemonList.length; indexPokemon++) {
        pokemonDetails = await fetchPokemonDetails(pokemonList[indexPokemon].url);
        renderPokemonList(contentRef, pokemonDetails);
    }
}

